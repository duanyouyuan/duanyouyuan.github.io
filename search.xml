<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/05/14/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Lambda-表达式简介"><a href="#Lambda-表达式简介" class="headerlink" title="Lambda 表达式简介"></a>Lambda 表达式简介</h2><p>Lambda 表达式是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p>
<p>你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。</p>
<span id="more"></span>
<h2 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h2><ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li>
<li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>示例 1：</p>
<p><code>使用Lambda表达式实现Runnable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        function1();</span><br><span class="line">        function2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*匿名内部类*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;thread1---匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Lambda表达式*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;thread2---Lambda表达式1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*只有一条语句，可以省略大括号*/</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;System.err.println(<span class="string">&quot;thread3---Lambda表达式2&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8的特性</title>
    <url>/2021/05/14/Java8%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Java8概述"><a href="#Java8概述" class="headerlink" title="Java8概述"></a>Java8概述</h1><ol>
<li><p>Java8（又称jdk1.8）是Java语言开发的一个主要版本。Oracle公司于2014年3月18日发布Java8</p>
</li>
<li><p>支持Lambda表达式</p>
</li>
<li><p>函数式接口</p>
</li>
<li><p>新的Stream API</p>
</li>
<li><p>新的日期 API</p>
</li>
<li><p>其他特性</p>
<span id="more"></span>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2></li>
<li><p>Lambda表达式：特殊的匿名内部类，语法更简洁</p>
</li>
<li><p>Lambda表达式允许把函数作为一个方法的参数（函数作为方法参数传递），将代码像数据一样传递</p>
</li>
<li><p>基本语法</p>
<p>&lt;<code>函数式接口</code>&gt; &lt;<code>变量名</code>&gt; =（<code>参数1</code>,<code>参数2</code>……）<code>-&gt;</code> {</p>
<p>​        //<code>方法体</code></p>
<p>}</p>
</li>
<li><p>Lambda引入了新的操作符 “ <code>-&gt;</code>“，左侧是参数列表，右侧是方法体</p>
</li>
<li><p>注意事项：</p>
<ol>
<li>形参列表的数据类型会自动推断</li>
<li>如果形参列表为空，只需保留 ( )</li>
<li>如果形参只有 1 个，( ) 可以省略，只需要参数的名字即可</li>
<li>如果执行语句只有 1 句，且无返回值，{} 可以省略，若有返回值，则若想省去 {} ，则必须同时省略 <code>return</code> ，且执行语句也保证只有 1 句</li>
<li>Lambda不会生成一个单独的内部类文件</li>
</ol>
</li>
</ol>
<p>示例：<em>实现Runnable</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        function1();</span><br><span class="line">        function2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*匿名内部类*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;thread1---匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Lambda表达式*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;thread2---Lambda表达式1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="comment">/*只有一条语句，可以省略大括号*/</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;System.err.println(<span class="string">&quot;thread3---Lambda表达式2&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ol>
<li>如果一个接口只有一个抽象方法，则该接口称之为函数式接口，函数式接口可以使用Lambda表达式，Lambda表达式会被匹配到这个抽象方法上</li>
<li>@FunctionalInterface注解 检测接口是否符合函数式接口</li>
<li>常见函数式接口：<ol>
<li>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）；</li>
<li>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）；</li>
<li>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数；</li>
<li>Consumer 接口表示执行在单个参数上的操作；</li>
<li>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法；</li>
<li>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型；</li>
</ol>
</li>
</ol>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol>
<li>方法引用是Lambda的一种简写形式 。如果Lambda表达式方法体中只是调用一个特定的已经存在的方法，则可以使用方法引用</li>
<li>常见形式：<ol>
<li>对象 <code>::</code> 实例方法</li>
<li>类 <code>::</code> 静态方法</li>
<li>类 <code>::</code> 实例方法</li>
<li>类 <code>::</code> new </li>
</ol>
</li>
</ol>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ol>
<li>流（Stream）中保存对集合或数组数据的操作。和集合类似，但集合中保存的是数据</li>
<li>Stream 自己不会存储元素</li>
<li>Stream 不会改变源对象。相反它们会返回一个持有结果的新 Stream</li>
<li>Stream 操作是延迟执行的。这意味着它们会等到需要结果的时候才会执行</li>
<li>Stream 使用步骤：<ol>
<li>创建：新建一个流</li>
<li>中间操作：在一个或多个步骤中，将初始Stream转化到另一个Stream的中间操作</li>
<li>终止操作：使用一个终止操作来产生一个结果。该操作会强制它之前的延迟操作立即执行。在这之后该Stream就不能使用了 </li>
</ol>
</li>
<li>创建Stream<ol>
<li>通过Collection对象的 stream( ) 或 parallelStream( ) 方法</li>
<li>通过Arrays 类的 stream( ) 方法</li>
<li>通过Stream接口的 of( )、iterate ( )、generate( )方法</li>
<li>通过IntStream、LongStream、DoubleStream接口中的 of 、range 、rangeClosed方法</li>
</ol>
</li>
<li>中间操作<ol>
<li>filter （概率）、limit （限制）、skip （跳过）、distinct （去重）、sorted（排序）</li>
<li>map</li>
<li>parallel （并行）</li>
</ol>
</li>
<li>终止操作<ol>
<li>forEach 、min 、max 、count 、map 、reduce （规约）、collect （收集）</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2的使用</title>
    <url>/2021/05/14/Swagger2%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="使用Swagger2"><a href="#使用Swagger2" class="headerlink" title="使用Swagger2"></a>使用Swagger2</h4><p>1、依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>2、配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.controller&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;段友元&quot;</span>, <span class="string">&quot;----------&quot;</span>, <span class="string">&quot;17371584524@163.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;UserApi&quot;</span>, <span class="string">&quot;用户管理接口&quot;</span>, <span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;urn:tos&quot;</span>,</span><br><span class="line">                contact, <span class="string">&quot;Apache 2.0&quot;</span>, <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>, <span class="keyword">new</span> ArrayList&lt;VendorExtension&gt;()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体类&quot;)</span></span><br><span class="line"><span class="comment">//注解在Entity类上</span></span><br><span class="line"><span class="meta">@ApiModelProperty(&quot;姓名&quot;)</span></span><br><span class="line"><span class="comment">//注解在Entity类字段上</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;用户管理&quot;)</span></span><br><span class="line"><span class="comment">//注解在Controller类上</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;查询全部&quot;)</span></span><br><span class="line"><span class="comment">//注解在Controller类API上</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka数据从一台机器copy到另一台机器上</title>
    <url>/2021/05/14/kafka%E6%95%B0%E6%8D%AE%E4%BB%8E%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8copy%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E4%B8%8A/</url>
    <content><![CDATA[<h4 id="kafka消息转移"><a href="#kafka消息转移" class="headerlink" title="kafka消息转移"></a>kafka消息转移</h4><p>使用多线程实现从133.0.120.193转移到133.0.189.157<br>利用它的订阅发布实现</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Runnable runnablec = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//配置信息</span></span><br><span class="line">                Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">                <span class="comment">//kafka服务器地址</span></span><br><span class="line">                props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;133.0.120.193:9092&quot;</span>);</span><br><span class="line">                <span class="comment">//必须指定消费者组</span></span><br><span class="line">                props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">                props.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>);</span><br><span class="line">                <span class="comment">//设置数据key和value的序列化处理类</span></span><br><span class="line">                props.put(<span class="string">&quot;key.deserializer&quot;</span>, StringDeserializer.class);</span><br><span class="line">                props.put(<span class="string">&quot;value.deserializer&quot;</span>, StringDeserializer.class);</span><br><span class="line">                <span class="comment">//创建消息者实例</span></span><br><span class="line">                KafkaConsumer&lt;Object,Object&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">                <span class="comment">//订阅topic1的消息</span></span><br><span class="line">                consumer.subscribe(Arrays.asList(<span class="string">&quot;eopstat&quot;</span>));</span><br><span class="line">                <span class="comment">//到服务器中读取记录</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    ConsumerRecords&lt;Object,Object&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">                    <span class="keyword">for</span>(ConsumerRecord&lt;Object,Object&gt; record : records)&#123;</span><br><span class="line">                        System.out.println( record.key() + <span class="string">&quot;&quot;</span> + <span class="string">&quot;,value:&quot;</span> + record.value());</span><br><span class="line">                        list.add(record.value());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable runnablep = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String topicName = <span class="string">&quot;eopstat&quot;</span>;</span><br><span class="line"></span><br><span class="line">                Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">                props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;133.0.189.157:9092&quot;</span>);</span><br><span class="line">                props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">                props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">                <span class="comment">/*创建生产者*/</span></span><br><span class="line">                Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">                <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">                    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topicName,o.toString());</span><br><span class="line">                    System.err.println(record);</span><br><span class="line">                    producer.send(record);</span><br><span class="line">                    System.out.println(o);</span><br><span class="line">                &#125;</span><br><span class="line">                producer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread threadc = <span class="keyword">new</span> Thread(runnablec);</span><br><span class="line">        Thread threadp = <span class="keyword">new</span> Thread(runnablep);</span><br><span class="line">        threadc.setPriority(<span class="number">8</span>);</span><br><span class="line">        threadp.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        threadc.start();</span><br><span class="line">        threadc.join(<span class="number">10000</span>);</span><br><span class="line">        threadp.start();</span><br><span class="line">        threadp.join(<span class="number">120000</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性拷贝</title>
    <url>/2021/05/14/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="使用org-springframework-beans-BeanUtils的对象拷贝"><a href="#使用org-springframework-beans-BeanUtils的对象拷贝" class="headerlink" title="使用org.springframework.beans.BeanUtils的对象拷贝"></a>使用org.springframework.beans.BeanUtils的对象拷贝</h2><h3 id="1、代码"><a href="#1、代码" class="headerlink" title="1、代码"></a>1、代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">        CollegeStudent col=<span class="keyword">new</span> CollegeStudent(<span class="string">&quot;段友元&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        System.err.println(col);</span><br><span class="line">        System.err.println(stu);</span><br><span class="line">        BeanUtils.copyProperties(col,stu);</span><br><span class="line">        System.err.println(stu);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="2、运行结果"><a href="#2、运行结果" class="headerlink" title="2、运行结果"></a>2、运行结果</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">CollegeStudent&#123;name=&#x27;段友元&#x27;, age=22, gender=&#x27;男&#x27;&#125;</span><br><span class="line">Student&#123;name=&#x27;null&#x27;, age=null&#125;</span><br><span class="line">Student&#123;name=&#x27;段友元&#x27;, age=22&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>对象拷贝</tag>
        <tag>BeanUtils</tag>
      </tags>
  </entry>
</search>
